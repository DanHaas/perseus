{"state":{"app_in_a_file":{"WithExcerpts":{"excerpts":"fn index_page<G: Html>(cx: Scope, state: &IndexStateRx) -> View<G> {\n    view! { cx,\n        h1 { (format!(\n            \"Hello, {}!\",\n            state.name.get()\n        )) }\n        input(\n            placeholder = \"Name\",\n            bind:value = state.name\n        )\n        a(href = \"about\") { \"About\" }\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, ReactiveState)]\n#[rx(alias = \"IndexStateRx\")]\nstruct IndexState {\n    name: String,\n}\n\n// This function will be run when you build your app, to generate default state\n// ahead-of-time\n#[engine_only_fn]\nasync fn get_build_state(_info: StateGeneratorInfo<()>) -> IndexState {\n    IndexState {\n        name: \"User\".to_string(),\n    }\n}","full":"use perseus::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse sycamore::prelude::*;\n\n// Initialize our app with the `perseus_warp` package's default server (fully\n// customizable)\n#[perseus::main(perseus_warp::dflt_server)]\npub fn main<G: Html>() -> PerseusApp<G> {\n    PerseusApp::new()\n        // Create a new template at `index`, which maps to our landing page\n        .template(\n            Template::build(\"index\")\n                .view_with_state(index_page)\n                .build_state_fn(get_build_state)\n                .build(),\n        )\n        .template(Template::build(\"about\").view(about_page).build())\n}\n\n#[auto_scope]\nfn index_page<G: Html>(cx: Scope, state: &IndexStateRx) -> View<G> {\n    view! { cx,\n        h1 { (format!(\n            \"Hello, {}!\",\n            state.name.get()\n        )) }\n        input(\n            placeholder = \"Name\",\n            bind:value = state.name\n        )\n        a(href = \"about\") { \"About\" }\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, ReactiveState)]\n#[rx(alias = \"IndexStateRx\")]\nstruct IndexState {\n    name: String,\n}\n\n// This function will be run when you build your app, to generate default state\n// ahead-of-time\n#[engine_only_fn]\nasync fn get_build_state(_info: StateGeneratorInfo<()>) -> IndexState {\n    IndexState {\n        name: \"User\".to_string(),\n    }\n}\n\nfn about_page<G: Html>(cx: Scope) -> View<G> {\n    view! { cx,\n        p { \"This is an example webapp created with Perseus!\" }\n    }\n}\n"}},"cli":{"Simple":"# üö© Get ready!\n> perseus init my-app\n\n# üì¶ All static?\n> perseus export -sw\n[1/3] üì¶ Exporting your app's pages...‚úÖ\n[2/3] üèóÔ∏è  Building your app to Wasm...‚úÖ\n[3/3] üõ∞Ô∏è  Your exported app is now live at <http://127.0.0.1:8080>!\n\n# üì° Using some more advanced features?\n> perseus serve -w\n[1/4] üî® Generating your app...‚úÖ\n[2/4] üèóÔ∏è  Building your app to Wasm...‚úÖ\n[3/4] üì° Building server...‚úÖ\n[4/4] üõ∞Ô∏è  Your app is now live on <http://127.0.0.1:8080>! To change this, re-run this command with different settings for `--host` and `--port`.\n\n# üß™ Testing your app's features?\n> perseus test\n# üîé Investigating some errors?\n> perseus snoop wasm-build\n\n# üéâ Ready to send it to the world?\n> perseus deploy\n"},"get_started":{"Simple":"> cargo install perseus-cli\n> perseus new my-project\n> perseus serve -w\n\n# Ready to deploy?\n> perseus deploy\n# And send `pkg/` to your server! ü•≥\n"},"i18n":{"WithExcerpts":{"excerpts":".locales_and_translations_manager(\n            \"en-US\",             // Default locale\n            &[\"fr-FR\", \"es-ES\"], // Other supported locales\n        )\n\n// ...\n\n// Our landing page. Going to `/` will cause a redirect to `/en-US`,\n// `/es-ES`, or `/fr-FR` based on the user's locale settings in their browser,\n// all automatically. If nothing matches, the default locale (`en-US`) will be\n// used.\nfn index_page<G: Html>(cx: Scope) -> View<G> {\n    view! { cx,\n        h1 { (t!(\"greeting\", cx)) }\n    }\n}\n\n// `translations/en-US.ftl`:\n//      greeting = Hello, world!\n// `translations/es-ES.ftl`:\n//      greeting = ¬°Hola, mundo!\n// `translations/fr-FR.ftl`:\n//      greeting = Bonjour, le monde!","full":"use perseus::prelude::*;\nuse sycamore::prelude::*;\n\n#[perseus::main(perseus_warp::dflt_server)]\npub fn main<G: Html>() -> PerseusApp<G> {\n    PerseusApp::new()\n        .template(Template::build(\"index\").view(index_page).build())\n                .locales_and_translations_manager(\n            \"en-US\",             // Default locale\n            &[\"fr-FR\", \"es-ES\"], // Other supported locales\n        )\n    }\n\n// Our landing page. Going to `/` will cause a redirect to `/en-US`,\n// `/es-ES`, or `/fr-FR` based on the user's locale settings in their browser,\n// all automatically. If nothing matches, the default locale (`en-US`) will be\n// used.\nfn index_page<G: Html>(cx: Scope) -> View<G> {\n    view! { cx,\n        h1 { (t!(\"greeting\", cx)) }\n    }\n}\n\n// `translations/en-US.ftl`:\n//      greeting = Hello, world!\n// `translations/es-ES.ftl`:\n//      greeting = ¬°Hola, mundo!\n// `translations/fr-FR.ftl`:\n//      greeting = Bonjour, le monde!\n"}},"state_generation":{"WithExcerpts":{"excerpts":"fn post_page<G: Html>(cx: Scope, state: &PostRx) -> View<G> {\n    view! { cx,\n        h1 { (state.title.get()) }\n        p { (state.author.get()) }\n        div(\n            dangerously_set_inner_html = &state.content.get()\n        )\n    }\n}\n\n// ...\n\n// This function will be run for each path under `/post/` to generate its state\n#[engine_only_fn]\nasync fn get_build_state(\n    StateGeneratorInfo { path, .. }: StateGeneratorInfo<()>,\n) -> Result<Post, BlamedError<MyError>> {\n    let raw_post = match get_post_for_path(path) {\n        Ok(post) => post,\n        // If the user sends us some bogus path with incremental generation,\n        // return a 404 appropriately\n        Err(err) => {\n            return Err(BlamedError {\n                blame: ErrorBlame::Client(Some(404)),\n                error: MyError(err),\n            })\n        }\n    };\n    let html_content = parse_markdown(raw_post.content);\n    let post = Post {\n        title: raw_post.title,\n        author: raw_post.author,\n        content: html_content,\n    };\n    Ok(post)\n}\n#[engine_only_fn]\nasync fn get_build_paths() -> BuildPaths {\n    BuildPaths {\n        // These will all become URLs at `/post/<name>`\n        paths: vec![\n            \"welcome\".to_string(),\n            \"really-popular-post\".to_string(),\n            \"foobar\".to_string(),\n        ],\n        // Perseus supports helper state, but we don't need it here\n        extra: ().into(),\n    }\n}","full":"use perseus::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::io;\nuse std::time::Duration;\nuse sycamore::prelude::*;\n\n#[perseus::main(perseus_warp::dflt_server)]\npub fn main<G: Html>() -> PerseusApp<G> {\n    PerseusApp::new().template(\n        Template::build(\"post\")\n            .view_with_state(post_page)\n            .build_paths_fn(get_build_paths)\n            .build_state_fn(get_build_state)\n            // Reload every blog post every day, in case it's changed\n            .revalidate_after(Duration::new(60 * 60 * 24, 0))\n            // If the user requests a page we haven't created yet, still\n            // pass it to `get_build_state()` and cache the output for\n            // future users (lazy page building)\n            .incremental_generation()\n            .build(),\n    )\n}\n\n#[auto_scope]\nfn post_page<G: Html>(cx: Scope, state: &PostRx) -> View<G> {\n    view! { cx,\n        h1 { (state.title.get()) }\n        p { (state.author.get()) }\n        div(\n            dangerously_set_inner_html = &state.content.get()\n        )\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, ReactiveState)]\n#[rx(alias = \"PostRx\")]\nstruct Post {\n    title: String,\n    author: String,\n    content: String,\n}\n\n// This function will be run for each path under `/post/` to generate its state\n#[engine_only_fn]\nasync fn get_build_state(\n    StateGeneratorInfo { path, .. }: StateGeneratorInfo<()>,\n) -> Result<Post, BlamedError<MyError>> {\n    let raw_post = match get_post_for_path(path) {\n        Ok(post) => post,\n        // If the user sends us some bogus path with incremental generation,\n        // return a 404 appropriately\n        Err(err) => {\n            return Err(BlamedError {\n                blame: ErrorBlame::Client(Some(404)),\n                error: MyError(err),\n            })\n        }\n    };\n    let html_content = parse_markdown(raw_post.content);\n    let post = Post {\n        title: raw_post.title,\n        author: raw_post.author,\n        content: html_content,\n    };\n    Ok(post)\n}\n#[engine_only_fn]\nasync fn get_build_paths() -> BuildPaths {\n    BuildPaths {\n        // These will all become URLs at `/post/<name>`\n        paths: vec![\n            \"welcome\".to_string(),\n            \"really-popular-post\".to_string(),\n            \"foobar\".to_string(),\n        ],\n        // Perseus supports helper state, but we don't need it here\n        extra: ().into(),\n    }\n}\n\n"}}},"head":"<title>Perseus</title><link rel=\"stylesheet\" href=\".perseus/static/prism.css\"/><link rel=\"prefetch\" href=\".perseus/static/mesh_open.jpg\"/><link rel=\"prefetch\" href=\".perseus/static/mesh_close.jpg\"/><link rel=\"prefetch\" href=\".perseus/static/cy-grotesk-grand-regular.woff2\"/>"}