{"state":"{\"app_in_a_file\":{\"WithExcerpts\":{\"excerpts\":\"#[perseus::template_rx]\\nfn index_page<'a, G: Html>(cx: Scope<'a>, props: IndexPropsRx<'a>) -> View<G> {\\n    view! { cx,\\n        h1 { (format!(\\n            \\\"Hello, {}!\\\",\\n            props.name.get()\\n        )) }\\n        input(\\n            placeholder = \\\"Name\\\",\\n            bind:value = props.name\\n        )\\n        a(href = \\\"about\\\") { \\\"About\\\" }\\n    }\\n}\\n\\n#[perseus::make_rx(IndexPropsRx)]\\nstruct IndexProps {\\n    name: String,\\n}\\n\\n// This function will be run when you build your app, to generate default state\\n// ahead-of-time\\n#[perseus::build_state]\\nasync fn get_index_build_state(\\n    _path: String,\\n    _locale: String,\\n) -> RenderFnResultWithCause<IndexProps> {\\n    let props = IndexProps {\\n        name: \\\"User\\\".to_string(),\\n    };\\n    Ok(props)\\n}\",\"full\":\"use perseus::{Html, PerseusApp, RenderFnResultWithCause, Template};\\nuse sycamore::prelude::*;\\n\\n// Initialize our app with the `perseus_warp` package's default server (fully\\n// customizable)\\n#[perseus::main(perseus_warp::dflt_server)]\\npub fn main<G: Html>() -> PerseusApp<G> {\\n    PerseusApp::new()\\n        // Create a new template at `index`, which maps to our landing page\\n        .template(|| {\\n            Template::new(\\\"index\\\")\\n                .template(index_page)\\n                .build_state_fn(get_index_build_state)\\n        })\\n        .template(|| Template::new(\\\"about\\\").template(about_page))\\n}\\n\\n#[perseus::template_rx]\\nfn index_page<'a, G: Html>(cx: Scope<'a>, props: IndexPropsRx<'a>) -> View<G> {\\n    view! { cx,\\n        h1 { (format!(\\n            \\\"Hello, {}!\\\",\\n            props.name.get()\\n        )) }\\n        input(\\n            placeholder = \\\"Name\\\",\\n            bind:value = props.name\\n        )\\n        a(href = \\\"about\\\") { \\\"About\\\" }\\n    }\\n}\\n\\n#[perseus::make_rx(IndexPropsRx)]\\nstruct IndexProps {\\n    name: String,\\n}\\n\\n// This function will be run when you build your app, to generate default state\\n// ahead-of-time\\n#[perseus::build_state]\\nasync fn get_index_build_state(\\n    _path: String,\\n    _locale: String,\\n) -> RenderFnResultWithCause<IndexProps> {\\n    let props = IndexProps {\\n        name: \\\"User\\\".to_string(),\\n    };\\n    Ok(props)\\n}\\n\\n#[perseus::template_rx]\\nfn about_page<G: Html>(cx: Scope) -> View<G> {\\n    view! { cx,\\n        p { \\\"This is an example webapp created with Perseus!\\\" }\\n    }\\n}\\n\"}},\"state_generation\":{\"WithExcerpts\":{\"excerpts\":\"#[perseus::template_rx]\\nfn post_page<'a, G: Html>(cx: Scope<'a>, props: PostRx<'a>) -> View<G> {\\n    view! { cx,\\n        h1 { (props.title.get()) }\\n        p { (props.author.get()) }\\n        div(\\n            dangerously_set_inner_html = &props.content.get()\\n        )\\n    }\\n}\\n\\n// ...\\n\\n// This function will be run for each path under `/post/` to generate its state\\n#[perseus::build_state]\\nasync fn get_build_state(path: String, _locale: String) -> RenderFnResultWithCause<Post> {\\n    let raw_post = match get_post_for_path(path) {\\n        Ok(post) => post,\\n        // If the user sends us some bogus path with incremental generation,\\n        // return a 404 appropriately\\n        Err(err) => blame_err!(client, 404, err),\\n    };\\n    let html_content = parse_markdown(raw_post.content);\\n    let props = Post {\\n        title: raw_post.title,\\n        author: raw_post.author,\\n        content: html_content,\\n    };\\n    Ok(props)\\n}\\nasync fn get_build_paths() -> RenderFnResult<Vec<String>> {\\n    // These will all become URLs at `/post/<name>`\\n    Ok(vec![\\n        \\\"welcome\\\".to_string(),\\n        \\\"really-popular-post\\\".to_string(),\\n        \\\"foobar\\\".to_string(),\\n    ])\\n}\",\"full\":\"use perseus::{blame_err, Html, PerseusApp, RenderFnResult, RenderFnResultWithCause, Template};\\nuse std::time::Duration;\\nuse sycamore::prelude::*;\\n\\n#[perseus::main(perseus_warp::dflt_server)]\\npub fn main<G: Html>() -> PerseusApp<G> {\\n    PerseusApp::new().template(|| {\\n        Template::new(\\\"post\\\")\\n            .template(post_page)\\n            .build_paths_fn(get_build_paths)\\n            .build_state_fn(get_build_state)\\n            // Reload every blog post every day, in case it's changed\\n            .revalidate_after(Duration::new(60 * 60 * 24, 0))\\n            // If the user requests a page we haven't created yet, still\\n            // pass it to `get_build_state()` and cache the output for\\n            // future users (lazy page building)\\n            .incremental_generation()\\n    })\\n}\\n\\n#[perseus::template_rx]\\nfn post_page<'a, G: Html>(cx: Scope<'a>, props: PostRx<'a>) -> View<G> {\\n    view! { cx,\\n        h1 { (props.title.get()) }\\n        p { (props.author.get()) }\\n        div(\\n            dangerously_set_inner_html = &props.content.get()\\n        )\\n    }\\n}\\n\\n#[perseus::make_rx(PostRx)]\\nstruct Post {\\n    title: String,\\n    author: String,\\n    content: String,\\n}\\n\\n// This function will be run for each path under `/post/` to generate its state\\n#[perseus::build_state]\\nasync fn get_build_state(path: String, _locale: String) -> RenderFnResultWithCause<Post> {\\n    let raw_post = match get_post_for_path(path) {\\n        Ok(post) => post,\\n        // If the user sends us some bogus path with incremental generation,\\n        // return a 404 appropriately\\n        Err(err) => blame_err!(client, 404, err),\\n    };\\n    let html_content = parse_markdown(raw_post.content);\\n    let props = Post {\\n        title: raw_post.title,\\n        author: raw_post.author,\\n        content: html_content,\\n    };\\n    Ok(props)\\n}\\nasync fn get_build_paths() -> RenderFnResult<Vec<String>> {\\n    // These will all become URLs at `/post/<name>`\\n    Ok(vec![\\n        \\\"welcome\\\".to_string(),\\n        \\\"really-popular-post\\\".to_string(),\\n        \\\"foobar\\\".to_string(),\\n    ])\\n}\\n\\n\"}},\"i18n\":{\"WithExcerpts\":{\"excerpts\":\".locales_and_translations_manager(\\n            \\\"en-US\\\",             // Default locale\\n            &[\\\"fr-FR\\\", \\\"es-ES\\\"], // Other supported locales\\n        )\\n\\n// ...\\n\\n// Our landing page. Going to `/` will cause a redirect to `/en-US`,\\n// `/es-ES`, or `/fr-FR` based on the user's locale settings in their browser,\\n// all automatically. If nothing matches, the default locale (`en-US`) will be\\n// used.\\n#[perseus::template_rx]\\nfn index_page<G: Html>(cx: Scope) -> View<G> {\\n    view! { cx,\\n        h1 { (t!(\\\"greeting\\\", cx)) }\\n    }\\n}\\n\\n// `translations/en-US.ftl`:\\n//      greeting = Hello, world!\\n// `translations/es-ES.ftl`:\\n//      greeting = ¬°Hola, mundo!\\n// `translations/fr-FR.ftl`:\\n//      greeting = Bonjour, le monde!\",\"full\":\"use perseus::{t, Html, PerseusApp, Template};\\nuse sycamore::prelude::*;\\n\\n#[perseus::main(perseus_warp::dflt_server)]\\npub fn main<G: Html>() -> PerseusApp<G> {\\n    PerseusApp::new()\\n        .template(|| Template::new(\\\"index\\\").template(index_page))\\n                .locales_and_translations_manager(\\n            \\\"en-US\\\",             // Default locale\\n            &[\\\"fr-FR\\\", \\\"es-ES\\\"], // Other supported locales\\n        )\\n    }\\n\\n// Our landing page. Going to `/` will cause a redirect to `/en-US`,\\n// `/es-ES`, or `/fr-FR` based on the user's locale settings in their browser,\\n// all automatically. If nothing matches, the default locale (`en-US`) will be\\n// used.\\n#[perseus::template_rx]\\nfn index_page<G: Html>(cx: Scope) -> View<G> {\\n    view! { cx,\\n        h1 { (t!(\\\"greeting\\\", cx)) }\\n    }\\n}\\n\\n// `translations/en-US.ftl`:\\n//      greeting = Hello, world!\\n// `translations/es-ES.ftl`:\\n//      greeting = ¬°Hola, mundo!\\n// `translations/fr-FR.ftl`:\\n//      greeting = Bonjour, le monde!\\n\"}},\"cli\":{\"Simple\":\"# üö© Get ready!\\n> perseus init my-app\\n\\n# üì¶ All static?\\n> perseus export -sw\\n[1/3] üì¶ Exporting your app's pages...‚úÖ\\n[2/3] üèóÔ∏è  Building your app to Wasm...‚úÖ\\n[3/3] üõ∞Ô∏è  Your exported app is now live at <http://127.0.0.1:8080>!\\n\\n# üì° Using some more advanced features?\\n> perseus serve -w\\n[1/4] üî® Generating your app...‚úÖ\\n[2/4] üèóÔ∏è  Building your app to Wasm...‚úÖ\\n[3/4] üì° Building server...‚úÖ\\n[4/4] üõ∞Ô∏è  Your app is now live on <http://127.0.0.1:8080>! To change this, re-run this command with different settings for `--host` and `--port`.\\n\\n# üß™ Testing your app's features?\\n> perseus test\\n# üîé Investigating some errors?\\n> perseus snoop wasm-build\\n\\n# üéâ Ready to send it to the world?\\n> perseus deploy\\n\"},\"get_started\":{\"Simple\":\"> cargo install perseus-cli\\n> perseus new my-project\\n> perseus serve -w\\n\\n# Ready to deploy?\\n> perseus deploy\\n# And send `pkg/` to your server! ü•≥\\n\"}}","head":"<title>Perseus</title><link rel=\"stylesheet\" href=\".perseus/static/prism.css\"/><link rel=\"prefetch\" href=\".perseus/static/mesh_open.jpg\"/><link rel=\"prefetch\" href=\".perseus/static/mesh_close.jpg\"/><link rel=\"prefetch\" href=\".perseus/static/cy-grotesk-grand-regular.woff2\"/>"}