{"state":{"content":"<h1>The State Platform</h1>\n<p>One of the features Perseus proclaims most is its advanced <em>state platform</em>, which isn't the simplest concept to explain, but it forms the 'secret sauce' that makes Perseus so powerful. As discussed on the <a href=\"https://framesurge.sh/perseus/en-US/docs/next/core-principles\">core principles page</a>, Perseus uses a template/page model, such that a page is the product of state going into a template, and you can generate that state in all sorts of ways. Now, let's dive into the specifics on this.</p>\n<p>One of the most powerful features of Perseus' state platform is that it spans both the engine-side and the browser-side: you can generate state in all sorts of ways on the engine-side (see the <a href=\"https://framesurge.sh/perseus/en-US/docs/next/reference/state-generation\">state generation page</a>), and then, when that state gets to your pages, it's 'reactive'. But what does this actually mean? Well, let's take an example state that a page in a music app might use:</p>\n<pre><code class=\"language-rust\">#[derive(Serialize, Deserialize, ReactiveState)]\nstruct Song {\n    title: String,\n    #[rx(nested)]\n    artist: Artist,\n    year: u32,\n    #[rx(nested)]\n    album: Album,\n}\n#[derive(Serialize, Deserialize, ReactiveState)]\nstruct Album {\n    title: String,\n    #[rx(nested)]\n    artist: Artist,\n    year: u32,\n    ty: AlbumType,\n    cover_art_url: String,\n}\n#[derive(Serialize, Deserialize)]\nenum AlbumType {\n    Single,\n    EP,\n    Album,\n}\n#[derive(Serialize, Deserialize, ReactiveState)]\nstruct Artist {\n    name: String,\n    bio: String,\n    profile_pic_url: String,\n}\n</code></pre>\n<p>Now, this is pretty complex for an example, and rightly so, we're going to dive into exactly how a real app might use Perseus' reactive state platform! Note that this will be a bit of a contrived example, since you probably wouldn't need <em>reactive</em> state in a music app, but that means we can use this example for both reactive and unreactive state!</p>\n<h2>State Generation</h2>\n<p>The first step in all this is actually getting some instances of this state, since we can't do anything with the state unless we know what it is! Above, we've defined a schema for it, but we need some actual values in there now. If we imagine there's a database of everything we need, we could use one of Perseus' many <a href=\"https://framesurge.sh/perseus/en-US/docs/next/reference/state-generation\">state generation strategies</a> to get that state at build-time, or even incrementally as users visit certain URLs, getting state as necessary. Since there's a <a href=\"https://framesurge.sh/perseus/en-US/docs/next/reference/state-generation\">whole separate page</a> on this, we'll leave it there for this, just imagine we've somehow gotten instances of our state into Perseus. Note that this stage will also involve defining all the paths under the URL <code>/song</code> that we want to create.</p>\n<h2>Passing State to a Template</h2>\n<p>Now that we have our many states (one for each song), we need to pass it to our <code>song</code> template, and use it to generate a number of pages. <strong>This entire stage is automatic, and occurs behind the scenes.</strong> In essence, Perseus will take in all the paths you've told it about, and it will get the state for those in parallel (e.g. you read a database to tell it about all the songs, and then it fetches each one and gets its state), building all the pages you need. Now, obviously, this involves sending the state you've generated to a page (we'll focus on just one page from now on, for simplicity), so how does this happen?</p>\n<p>Well, when you generated state, you generated an instance of <code>Song</code>, but, if we want our state to be <em>reactive</em>, then we'll have to do better. Reactive state is state that you can call <code>.get()</code> and <code>.set()</code> on. The most obvious usage of it is inside a form: let's say you're building a user interface that involves the user inputting some values, well, you could use Sycamore's <code>bind:value</code> on each of the <code>input</code> elements to store the state of each input reactively. But, rather than creating all the variables to do this inside your template, you can accept these as state, like so:</p>\n<pre><code class=\"language-rust\">#[template]\nfn my_template&lt;'a, G: Html&gt;(cx: Scope&lt;'a&gt;, state: PageStateRx&lt;'a&gt;) -&gt; View&lt;G&gt; {\n    view! { cx,\n        form {\n            input(bind:value = state.name, placeholder = &quot;Name&quot;)\n            input(bind:value = state.email, placeholder = &quot;Email&quot;)\n            // ...\n        }\n    }\n}\n</code></pre>\n<p>See what we mean? It's much more convenient if every single one of the fields of <code>state</code> is <em>reactive</em>, meaning it's wrapped in a Sycamore <code>Signal</code>. (If you haven't read the Sycamore docs yet, now would be a good time!) Otherwise, you'd have to create all the <code>Signal</code>s you need at the start of your template function.</p>\n<p>But this isn't just for convenience, it also serves a practical function: Perseus automatically caches all reactive state internally, meaning the changes the user makes to those inputs will be reflected inside Perseus' cache. And, when they come back to that page later, <em>the state will be restored from the cache</em>, meaning the inputs are just as they left them. This means users can navigate fearlessly around any Perseus app using reactive state, without fear of losing their place.</p>\n<p><em>(It actually gets even better than this, but keep reading!)</em></p>\n<p>Now, what matters behind the scenes is that we can turn the unreactive state you gave to Perseus into reactive state. Since we're making all the fields of the <code>Song</code> <code>struct</code> reactive, in the above example, this will involve a macro: <code>#[derive(ReactiveState)]</code> (we also derive <code>Serialize</code> and <code>Deserialize</code> from Serde, since Perseus needs to send this state over a network connection from server to browser). Now, this derive macro is more complex than most: it takes in the <code>struct</code> you give it, and derives the <code>MakeRx</code> trait on it, which means it can be converted into some reactive type. Then, it actually <em>creates</em> a whole new <code>struct</code> called <code>SongPerseusRxIntermediate</code> (which you should never have to touch) that has all its fields wrapped in <code>RcSignal</code>s. The reason we don't just go straight to a <code>Signal</code> is because, as we mentioned earlier, Perseus caches all reactive state at the application-level, which means it has to outlive all your templates, so, for the lifetimes to work out, we use <code>RcSignal</code>s.</p>\n<p>Now, if you've worked with lifetimes long enough in Sycamore (no problem if you haven't), you'll know that this will lead to some really poor ergonomics: using <code>RcSignal</code>s, we would have to <code>.clone()</code> almost everything we want to use inside <code>view!</code>. But, this is where that macro comes to the rescue again! It creates <em>another</em> <code>struct</code> called <code>SongPerseusRxRef</code> (which you shouldn't have to touch by that name, we'll get to naming), which has all the fields of the original <code>Song</code> wrapped in <code>&amp;'cx RcSignal</code>, where <code>cx</code> is the lifetime of the page the state is being used in. Basically, you can imagine it like this: we take unreactive state, make it reactive at the application-level, and then register it as a reference on each page it's used in when we need to, to get the best ergonomics possible.</p>\n<p>But, if it encounters an <code>#[rx(nested)]</code> helper macro on any of your fields, it will assume the type of that field also has <code>ReactiveState</code> derived, and it will automatically use the reactive version of it. In our example above, this means we wouldn't be getting the artist of a song's name by going <code>song.artist.get().name</code>, we could use the far better <code>song.artist.name.get()</code>! This improves ergonomics substantially in complex apps (while also allowing <em>very</em> fine-grained state control).</p>\n<p>[TODO implementation on <code>Vec</code> etc.]</p>\n<p>Importantly, especially if you ever need to implement all this without the macro (e.g. if your page's state is an <code>enum</code> rather than a <code>struct</code>), the intermediate reactive type (the one with pure <code>RcSignal</code>s) implements three traits: <code>MakeUnrx</code> (which allows it to be turned back into a <code>Song</code>), <code>MakeRxRef</code> (which allows it to be turned into the final type using references), and <code>Freeze</code> (we'll get to this). The original <code>Song</code> just implements <code>MakeRx</code>, and the final reference <code>struct</code> implements <code>RxRef</code>, a simple linking trait that has no methods, but that just defines the <code>RxNonRef</code> associated type to be the intermediate type. By linking the three types together like this, Perseus can take in whichever is most ergonomically convenient and work with it! For instance, there are plenty of internal methods that have access to the intermediate type, but that need to go back to the original, and they easily can with this mechanism.</p>\n<p>So, in the <code>#[template]</code> macro, Perseus takes in your generated, unreactive state, and checks if a reactive version has already been cached (e.g. the user has already been to this page). If there is, it'll use that, and, otherwise, it'll make the unreactive thing it was given reactive, cache that for the first time for future use, and then give a reference version to your code! Since this code is basically the same for every template, we do it with a macro to minimize the overhead.</p>\n<p><em>Note: there are plans currently to remove the <code>#[template]</code> macro entirely, eventually, though this will involve significant alterations to the Perseus core.</em></p>\n<p>Of course, you probably don't want to reference your reactive type using something like <code>&lt;&lt;Song as ::perseus::state::MakeRx&gt;::Rx as ::perseus::state::MakeRxRef&gt;::RxRef&lt;'__derived_rx&gt;;</code>, so you can use the <code>#[rx(alias = &quot;SongRx&quot;)]</code> helper macro to define an alias for the final reactive reference <code>struct</code>, which takes the same lifetime as the Sycamore <code>Scope</code> of the page it's being used in.</p>\n<h2>Unreactive State</h2>\n<p>The other thing we could do is have out song state be unreactive, since, after all, it's pretty unlikely that the user is going to be renaming a song inside our music app (remember that the <code>.set()</code> method simply changes the state locally, it doesn't change anything on the engine-side or in a database, unless you code that yourself).</p>\n<p>To do this, we would remove all those <code>#[rx(nested)]</code> helper macros, and simply change <code>ReactiveState</code> to <code>UnreactiveState</code> in that <code>#[derive(...)]</code> call at the top. (We also wouldn't need to derive <code>ReactiveState</code> or <code>UnreactiveState</code> on anything other than <code>Song</code>). Importantly, you'll also need to change <code>#[template]</code> to <code>#[template(unreactive)]</code> in the function you're using to render <code>Song</code>s.</p>\n<p>Now, you're probably wondering why on earth we have to specially derive <code>UnreactiveState</code>, when we're just going to get the exact same thing as we generated! Well, your type still has implement the special <code>Freeze</code> trait, and the Perseus state platform is built for storing explicitly reactive state. So, what that <code>UnreactiveState</code> derive macro actually does is basically exactly the same as the <code>ReactiveState</code> macro, except, rather than wrapping your fields in <code>Signal</code>s, it uses a special <code>UnreactiveState</code> wrapper, which basically makes your state <em>look</em> reactive to Perseus, but, when you use <code>#[template(unreactive)]</code>, it can know to get rid of those wrappers and give you the original type you generated.</p>\n<h2>Freezing</h2>\n<p>Earlier, we mentioned a <code>Freeze</code> trait that the intermediate reactive type implements, which is the core of Perseus' unique <em>state freezing</em> system. Up to now, we have the ability with Perseus to let users go between pages and have the state of each page stored perfectly, as long as they're still on the site. Of course, once they leave the site, or reload the page, that will all be lost, but what if we could preserve it somehow?</p>\n<p>Well, conveniently, all the state in a Perseus app has to be both <code>Serialize</code> and <code>Deserialize</code>, since it needs to be turned into a <code>String</code> to be sent from the server to the user's browser. But, what if we took all the intermediate reactive types in an app, converted them back into their unreactive versions, and serialized those to <code>String</code>s? What if we added some internal Perseus state, any global state, and the current route? Put that all together as a JSON object, and you would have a <code>String</code> representation of the <em>exact</em> state of an app, from a user's perspective.</p>\n<p><em>That</em> is what the <code>Freeze</code> trait enables. As explained above, to achieve this, you would need to take each intermediate reactive type, turn it into its unreactive version, and serialize it to a <code>String</code>. To allow flexibility in this, Perseus requires such intermediate types to implement <code>Freeze</code>, which just has the <code>.freeze()</code> method, which simply produces a <code>String</code> representation of that type.</p>\n<p>If you want to see how you can freeze and entire Perseus app, check out <a href=\"https://github.com/framesurge/perseus/tree/main/examples/core/freezing_and_thawing\">this example</a>. Alternately, take a look at <a href=\"https://github.com/framesurge/perseus/tree/main/examples/core/idb_freezing\">this one</a> to see how you can easily store the resulting frozen app to IndexedDB (a native in-browser storage system)!</p>\n<p>Of course, if we can freeze, we need to be able to <em>thaw</em> too, right? Well, Perseus makes this pretty much trivial, since you can register a frozen app <code>String</code> that will be progressively unwrapped as necessary. In essence, rather than restoring the whole state of the app at once, Perseus simply restores the internal state and takes the user to whatever route they were on at the last freeze, and then restores each page's state on-demand: we leave it frozen until the user goes to that exact page. The same thing applies to the global state: it will only be thawed when it's first used. That not only mitigates the need for you to specify all your state types to a single thaw command, but it also means that any page states that are no longer valid can be silently ignored (e.g. if the app's code has changed since the freeze). This means users get the best replication of the previous state possible, even if the thaw is years later.</p>\n<p>As a side note, this is exactly how Perseus' HSR (hot state reloading) system works! In JavaScript frameworks, you can split up all your JS files into many small <em>chunks</em>, and then, when you as a developer change some code and want to see the result, the framework just reloads the necessary chunks, meaning most things should stay the same. Since we can't chunk Wasm files (yet), Perseus just freezes your app's state to IndexedDB, and restores it after a page reload. From your perspective, the page has reloaded to exactly the same place. When you're fifteen pages into a login form and trying to realign a button, making sure you don't have to go back to beginning of that flow whenever you change some code becomes pretty useful! That said, you can easily disable HSR by turning off the default feature flag <code>hsr</code>.</p>\n","current_version":"next","manifest":{"0.1.x":{"docs_rs":"0.1","git":"v0.1.4","state":"outdated"},"0.2.x":{"docs_rs":"0.2","git":"v0.2.3","state":"outdated"},"0.3.0-0.3.3":{"docs_rs":"0.3.3","git":"v0.3.3","state":"outdated"},"0.3.4":{"docs_rs":"0.3","git":"v0.3.6","state":"stable"},"0.4.x":{"docs_rs":"0.4.0-beta","git":"HEAD","state":"beta"}},"sidebar_content":"<h1>Introduction</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/quickstart\">Quickstart</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/what-is-perseus\">What is Perseus?</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/core-principles\">Core Principles</a></li>\n</ul>\n<h1>Your First App</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/installation\">Installing Perseus</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/defining\">Defining your app</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/generating-pages\">Generating pages</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/dev-cycle\">Development cycle</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/error-handling\">Error handling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/deploying\">Deploying your app</a></li>\n</ul>\n<h1>Fundamentals</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/perseus-app\"><code>PerseusApp</code></a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/reactor\">The reactor</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/routing\">Routing and navigation</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/preloading\">Preloading</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/i18n\">Internationalization</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/error-views\">Error views</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/hydration\">Hydration</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/static-content\">Static content</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/headers\">Setting headers</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/styling\">Styling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/js-interop\">Working with JS</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/serving-exporting\">Servers and exporting</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/debugging\">Debugging</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/testing\">Writing tests</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/plugins\">Plugins</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/compilation-times\">Improving Compilation Times</a></li>\n</ul>\n<h1>The State Platform</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/intro\">Understanding state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/build\">Build-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/request\">Request-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/revalidation\">Revalidation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/incremental\">Incremental generation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/amalgamation\">State amalgamation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/browser\">Using state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/global\">Global state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/helper\">Helper state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/suspense\">Suspended state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/freezing-thawing\">Freezing and thawing</a></li>\n</ul>\n<h1>Capsules</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/capsules-vs-templates\">Capsules vs. templates</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/delayed\">Delayed widgets</a></li>\n</ul>\n<h1>Miscellaneous</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/migrating\">Migrating from v0.3.x</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/faq\">Common pitfalls and FAQs</a></li>\n</ul>\n","status":"Next","title":"The State Platform"},"head":"<title>The State Platform | Perseus Docs</title><link rel=\"stylesheet\" href=\".perseus/static/styles/markdown.css\"/><link rel=\"stylesheet\" href=\".perseus/static/styles/docs_links_markdown.css\"/><link rel=\"stylesheet\" href=\".perseus/static/prism.css\"/>"}