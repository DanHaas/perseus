{"state":{"content":"<h1>Incremental generation</h1>\n<p>One of the most powerful features of Perseus' state generation platform is the <em>incremental generation</em> system, which can be thought of as the request-time counterpart to the <em>build paths</em> strategy. Let's say you run an e-commerce website, and you have ten million products. Do you want to build ten million pages at build-time? Probably not!</p>\n<p>A much better way of handling this would be to instead pre-render only your top 100 products or so at build-time (remember that Perseus builds are lightning fast after Rust compilation, so even that many is still light; this website generates several hundred documentation pages in less than half a second), and somehow render the others later, only when they're requested. This kind of 'on-demand' approach would be best if, when a user requested a page that wasn't prerendered at build-time, it's not just built for them, but also cached for future use, <em>as if</em> it had been built at build time. This kind of extension of the build process to just keep happening also allows you to add new products to your site in the future, and they'll be prerendered properly the first time somebody requests them (using <a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/revalidation\">revalidation</a> on some kind of inventory page makes the most sense here).</p>\n<p>All this is supported with literally one single line of code: <code>.incremental_generation()</code>. No arguments, no special functions, that's all you need, and Perseus will change its routing algorithm slightly to still match all the pages you render at build-time, but to also say &quot;when a page under this template is requested that we don't know about yet, bear with it and try it out on the server anyway&quot;. The server will see if it's been prerendered in the past, and it'll provide it if it was, and otherwise it will run your <code>get_build_state</code> function, providing whatever path the user gave.</p>\n<p>Of course, this could mean that somebody might go to the page <code>/product/faster-than-light-engine</code>, which might unfortunately still be in development, so that page shouldn't exist. And <em>this</em> is why we have <code>BlamedError&lt;E&gt;</code> in build state! So that you can say &quot;if this page actually shouldn't exist, return an error that's blamed on the <em>client</em>, with HTTP status 404&quot;. This will be rendered by Perseus into a <em>404 Not Found</em> page automatically (but error views won't be cached, meaning that, if this product becomes available in the future, everything will work out).</p>\n<p>Note that incremental generation is fully compatible with all other state generation methods, including request-time state generation and both forms of revalidation.</p>\n<p>Here's an example of incremental generation:</p>\n<pre><code class=\"language-rust\">// This is exactly the same as the build paths example except for a few lines\n// and some names\n\nuse perseus::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse sycamore::prelude::*;\n\n#[derive(Serialize, Deserialize, Clone, ReactiveState)]\n#[rx(alias = &quot;PageStateRx&quot;)]\nstruct PageState {\n    title: String,\n    content: String,\n}\n\nfn incremental_generation_page&lt;'a, G: Html&gt;(\n    cx: BoundedScope&lt;'_, 'a&gt;,\n    state: &amp;'a PageStateRx,\n) -&gt; View&lt;G&gt; {\n    view! { cx,\n        h1 {\n            (state.title.get())\n        }\n        p {\n            (state.content.get())\n        }\n    }\n}\n\npub fn get_template&lt;G: Html&gt;() -&gt; Template&lt;G&gt; {\n    Template::build(&quot;incremental_generation&quot;)\n        .build_paths_fn(get_build_paths)\n        .build_state_fn(get_build_state)\n        // This line makes Perseus try to render any given path under the template's root path\n        // (`incremental_generation`) by putting it through `get_build_state` If you want to\n        // filter the path because some are invalid (e.g. entries that aren't in some database), we\n        // can filter them out at the state of the build state function\n        .incremental_generation()\n        .view_with_state(incremental_generation_page)\n        .build()\n}\n\n// This will be executed at build-time for all the paths in `get_build_paths()`,\n// and then again for any other paths that a user might request while the app is\n// live, meaning any errors could come from either the server or the client,\n// hence why this returns a `BlamedError`. We use a `std::io::Error` because we\n// need soemthing that implements `std::error::Error`, but you could use\n// anything here.\n#[engine_only_fn]\nasync fn get_build_state(\n    StateGeneratorInfo { path, .. }: StateGeneratorInfo&lt;()&gt;,\n) -&gt; Result&lt;PageState, BlamedError&lt;std::io::Error&gt;&gt; {\n    // This path is illegal, and can't be rendered\n    // Because we're using incremental generation, we could get literally anything\n    // as the `path`\n    if path == &quot;tests&quot; {\n        // This tells Perseus to return an error that's the client's fault, with the\n        // HTTP status code 404 (not found) and the message 'illegal page'. Note that\n        // this is a `BlamedError&lt;std::io::Error&gt;`, but we could use any error type that\n        // implements `std::error::Error` (note that this does make `anyhow` a\n        // bit tricky, if you use it).\n        return Err(BlamedError {\n            // If we used `None` instead, it would default to 400 for the client and 500 for the\n            // server\n            blame: ErrorBlame::Client(Some(404)),\n            // This is just an example, and you could put any error type here, usually your own\n            error: std::io::Error::new(std::io::ErrorKind::NotFound, &quot;illegal page&quot;),\n        });\n    }\n    let title = path.clone();\n    let content = format!(\n        &quot;This is a post entitled '{}'. Its original slug was '{}'.&quot;,\n        &amp;title, &amp;path\n    );\n\n    Ok(PageState { title, content })\n}\n\n// See `../build_paths.rs` for an explanation of this\n#[engine_only_fn]\nasync fn get_build_paths() -&gt; BuildPaths {\n    BuildPaths {\n        paths: vec![&quot;test&quot;.to_string(), &quot;blah/test/blah&quot;.to_string()],\n        extra: ().into(),\n    }\n}\n\n</code></pre>\n<p>Note the use of build paths (you still have to generate <em>some</em> pages, otherwise incremental generation will be completely ignored and you'll just get an index page), and the conditional in <code>get_build_state</code> that checks for the illegal path <code>tests</code>, returning a <code>BlamedError</code> with blame <code>ErrorBlame::Client(Some(404))</code>, where <code>404</code> is the HTTP status code for a page not being found! Here, we're accompanying that with a <code>std::io::Error</code>, but you could use any error type you like.</p>\n<p>Note that incrementally generated pages will be placed in the mutable store, which you shoudl keep in mind when deploying to read-only environments, such as serverless functions (see [here] for details).</p>\n<details>\n<summary>How does Vercel handle that?</summary>\n<p>If you're from the JS world, you might be familiar with NextJS, which also supports incremental generation, but they offer a serverless function service that works with it seamlessly. Details about how this works are not public, but they seem to be using a colocated database setup to achieve this, or they may be using function-specific incremental caches (which would lead to lower performance, so this is unlikely).</p>\n<p>You might wonder if Perseus could run in the same system. So have we, and this is an avenue we intend to explore in 2023.</p>\n</details>\n","current_version":"next","manifest":{"0.1.x":{"docs_rs":"0.1","git":"v0.1.4","state":"outdated"},"0.2.x":{"docs_rs":"0.2","git":"v0.2.3","state":"outdated"},"0.3.0-0.3.3":{"docs_rs":"0.3.3","git":"v0.3.3","state":"outdated"},"0.3.4":{"docs_rs":"0.3","git":"v0.3.6","state":"stable"},"0.4.x":{"docs_rs":"0.4.0-beta","git":"HEAD","state":"beta"}},"sidebar_content":"<h1>Introduction</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/quickstart\">Quickstart</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/what-is-perseus\">What is Perseus?</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/core-principles\">Core Principles</a></li>\n</ul>\n<h1>Your First App</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/installation\">Installing Perseus</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/defining\">Defining your app</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/generating-pages\">Generating pages</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/dev-cycle\">Development cycle</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/error-handling\">Error handling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/deploying\">Deploying your app</a></li>\n</ul>\n<h1>Fundamentals</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/perseus-app\"><code>PerseusApp</code></a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/reactor\">The reactor</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/routing\">Routing and navigation</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/preloading\">Preloading</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/i18n\">Internationalization</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/error-views\">Error views</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/hydration\">Hydration</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/static-content\">Static content</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/head-headers\">Heads and headers</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/styling\">Styling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/js-interop\">Working with JS</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/serving-exporting\">Servers and exporting</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/debugging\">Debugging</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/testing\">Writing tests</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/plugins\">Plugins</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/compilation-times\">Improving Compilation Times</a></li>\n</ul>\n<h1>The State Platform</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/intro\">Understanding state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/build\">Build-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/request\">Request-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/revalidation\">Revalidation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/incremental\">Incremental generation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/amalgamation\">State amalgamation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/browser\">Using state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/global\">Global state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/helper\">Helper state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/suspense\">Suspended state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/freezing-thawing\">Freezing and thawing</a></li>\n</ul>\n<h1>Capsules</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/capsules-vs-templates\">Capsules vs. templates</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/delayed\">Delayed widgets</a></li>\n</ul>\n<h1>Miscellaneous</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/migrating\">Migrating from v0.3.x</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/faq\">Common pitfalls and FAQs</a></li>\n</ul>\n","status":"Next","title":"Incremental generation"},"head":"<title>Incremental generation | Perseus Docs</title><link rel=\"stylesheet\" href=\".perseus/static/styles/markdown.css\"/><link rel=\"stylesheet\" href=\".perseus/static/styles/docs_links_markdown.css\"/><link rel=\"stylesheet\" href=\".perseus/static/prism.css\"/>"}