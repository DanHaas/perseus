# Internationalization

Internationalization, or *i18n* for short, is the process of making your app available in many languages, something Perseus supports out of the box!

Usually, i18n is done in one of two ways: by having subdomains for each different locale (e.g. `en.example.com`, `de.example.com`), or by having each locale have a separate top-level route (e.g. `example.com/en`, `example.com/de`). Perseus favors the latter approach, which requires less routing overhead (you don't have to manage subdomains), and is generally easier to set up.

The process of i18n is mostly behind-the-scenes in Perseus, but what it involves at heart is this: each template is built once for each locale, with a different language parameter provided. That parameter allows you to, in your code, detect the locale being used, and provide the right translation of your page's content. Perseus also takes this one step further by providing an inbuilt `TranslationsManager` system, which is used to find translations in the `translations/` folder at the root of your project, which can then be interpolated into your page with the `t!` macro. All examples are available [here]().

Specifically, Perseus uses the [Fluent](https://projectfluent.org) translation system, which provides a file format with full support for managing variable interpolation, plurals, genders, etc. The `t!` macro allows working with most of these features, though for some more advanced use-cases you'll need to drill down into the `Translator` instance itself, an example of which can be found [here]().

Not everyone appreciates Fluent though, and there are plenty of other translations systems that exist today. Perseus manages translators on a feature-flag system (so you enable `translator-fluent` to use the default Fluent system), which means more translators can be built into Perseus without any cost to bundle sizes. Currently, only Fluent is supported, though we're happy to accept [PRs]() or [issues]() implementing or proposing more systems!

The last thing to understand about Perseus' approach to i18n is how we manage translations. You'll store your translations for each locale somewhere like `translations/en-US.ftl` (from the root of your project), but this isn't always the ideal system. Sometimes, for example, you'll want to fetch translations from a database instead, if they're being regularly updated. This can be done by using an alternative to `FsTranslationsManager`, as long as it implements `TranslationsManager`. An example for this can be found [here](). Note that translations will be fetched extremely regularly, so it's generally not recommended to use high-latency managers in server-based applications. If you use `perseus export`, then all translations are automatically hardcoded, though `perseus serve` will fetch them all as it starts up, caching them. (You should never update translations without rebuilding your app, as this could lead to unexpected results.) The translations that are cached immediately can be changed as per [this example]().

*Note for contributors: there is a `struct ClientTranslationsManager` also present in the codebase, which is responsible for caching translations in the browser. It is not customizable, and has no relation to the `trait TranslationsManager` used on the engine-side.*
